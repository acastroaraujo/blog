---
title: "What is Sociology in the USA?"
description: |
  A visualization.
author: andrés castro araújo
date: 2023-12-22
draft: true
bibliography: references.bib
echo: false
editor_options: 
  chunk_output_type: inline
---

```{r}
#| label: "Set up"
#| message: false

# Packages
library(tidyverse)
library(igraph)
library(Matrix)
library(gt)
library(visNetwork)

theme_set(theme_light(base_family = "Optima"))

# Load Data
d <- read_rds("edge_list.rds")

## Matrix

el <- d |> 
  unnest(cols = data) |> 
  select(name, area = areas_of_interest) |> 
  mutate(area = ifelse(str_detect(area, "(P|p)olicy"), "Policy", area)) |> 
  distinct(name, area)

rownms <- unique(el$name)
colnms <- unique(el$area)

i <- match(el$name, rownms)
j <- match(el$area, colnms)

X <- sparseMatrix(
  i = i, j = j, x = 1L, dimnames = list(rownms, colnms)
)

A <- t(X) %*% X

i <- seq(0.01, 0.1, by = 0.02)

nets <- map(i, function(x) {
  
  out <- backbone::disparity(A, alpha = x, class = "igraph", signed = FALSE)
  V(out)$size <- diag(A)
  V(out)$degree <- degree(out)
  
  cluster <- as.integer(membership(cluster_walktrap(out))) 
  tbl <- sort(table(cluster)[table(cluster) > 1], decreasing = TRUE) 
  lookup <- setNames(letters[seq_along(tbl)], as.integer(names(tbl)))
  
  V(out)$group <- lookup[as.character(cluster)]
  V(out)$group[is.na(V(out)$group)] <- "isolate"
  V(out)$name <- stringr::str_wrap(V(out)$name, 12)
  
  return(out)
  
})

# Helpers
rescale <- function(x, low = 1, high = 30) {
  r <- range(x)
  out <- (x - r[1]) / (r[2] - r[1])
  out * (high - low) + low
}

vis_plot <- function(x) {
  # pre-process
  vnd <- toVisNetworkData(x, idToLabel = FALSE)
  vnd$nodes$label <- vnd$nodes$id
  vnd$nodes$title <- paste("Size:", vnd$nodes$size, "</br>", "Degree:", vnd$nodes$degree)
  vnd$nodes$value <- rescale(vnd$nodes$degree)

  # plot
  visNetwork(vnd$nodes, vnd$edges) |> 
   visIgraphLayout(layout = "layout_with_graphopt", physics = TRUE) |> 
   visEdges(color = list(inherit = "to")) |> 
   visNodes(label = list(inherit = "to")) |> 
   visOptions(
     selectedBy = "group",
       nodesIdSelection = TRUE,
     highlightNearest = list(enabled = TRUE, hover = TRUE, labelOnly = TRUE, degree = 1)
   ) |> 
   visPhysics(
     solver = "barnesHut", 
     maxVelocity = 3, 
     barnesHut = list(theta = 0.1, gravitationalConstant = -3000, centralGravity = 0.5)
   )   
}

```

***Note. The visualization provided below is provisional. I need to email someone at the ASA and politely ask for permission to use the full dataset.***

Sociologists in the USA like to describe sociology as the most heterogeneous social science of all, to the point that some seem to think of it as a miniature version of *all* social science. Andrew @abbott2001 claims sociology's defining characteristic is "the fact that the discipline is not very good at excluding things from itself." In this view, the lack of "internal cohesion" is the cost we've paid in exchange for occupying a central place in the social science landscape [@moody2006].

> It is the most heterogeneous social science, which is perhaps another way of saying that it has been less successful at institutionalizing itself as a discipline than its close relatives. Unlike economics, it does not have a core kit of analytical tools and models codified in textbooks and widely accepted as legitimate both inside and outside the field... Unlike political science, on the other hand, sociology does not have a well-defined empirical core to unify it, either.
>
> @healy2012 [pp. 88]

**Glass half-full**

The absence of a disciplinary core has been celebrated by many as some unique form of academic freedom.

This is the reason why many people *claim* they *chose* to become a sociologist.

> I chose sociology because more than any other social science sociology would let me do what I pleased. If I went into sociology, I wouldn't have to make up my mind what to do.
>
> ---Andrew Abbott
>
> Whey, then, did I choose sociology as an academic home?
>
> Of all the available social sciences, sociology seemed to me to be the *least disciplinary;* it had the fuzziest boundaries. But even more significantly, sociology has valued its own marginal traditions in a way that other social sciences don't.
>
> ---Erik Olin Wright

**Glass half-empty**

Others are less optimistic.

Presumably, we are not as interdisciplinary as we'd like to believe.

> ...most sociologists don't really get interdisciplinarity. Whether we acknowledge it or not, most of us have internalized a sociological supremacy that makes us believe our field's insights are more important, more complete, more *nuanced* than those of other scientists (Healy 2017). This cultural background of intellectual superiority helps create what Lizardo (2014) called the "Comtean schema"---the implicit belief that all proper interdisciplinary research should take the institutional form of a *subfield of sociology.*
>
> In a brilliant insight, Lizardo noted that sociologists create virtual "avatars" of other disciplines within sociology instead of working with their real-world counterparts. That is, rather than engage with economists, we create "economic sociology"; rather than engage with political science, we have "political sociology"; rather than engage with cultural evolution or cognitive science, we invent "the sociology of culture and cognition," and so on. This fools us into thinking that we're being interdisciplinary when, in reality, "\[t\]hese subdisciplinary avatars have been created by sociologists for sociological consumption" (Lizardo 2014:985).
>
> @vaisey2021 [pp. 1298]

## Data

When a sociologist joins the *American Sociological Association* (ASA), they have the opportunity to choose up to four "areas of interest." For example, I chose (1) Theory; (2) Quantitative Methodology; (3) Organizations, Formal and Complex; and (4) Law and Society. And I would probably choose something different on another day.

So, I created a dataset containing the areas of interest of over 1,000 individuals associated with 20 sociology programs in the USA. This dataset is provisional, but see @tbl-sample in case you are curious about the sample.

Each of these individuals chose anywhere between one and four areas of interest. @fig-areas highlights the ten largest areas of interest in [blue]{style="color:#63B8FF;"} . The largest is *stratification/mobility,* which gives credence to the idea that inequality defines the subject-matter of sociology. Among the top ten we also find what some may describe as subdisciplinary avatars---*Cultural*, *Economic*, and *Political* Sociology---which gives credence to the idea that sociology is a miniature version of all social science. Furthermore, the idea that sociology is mostly concerned with race, class, and gender is also well represented in this top ten.

```{r}
#| label: fig-areas
#| fig-cap: "Areas of Interest in The Dataset"
#| column: page
#| fig-width: 12
#| fig-height: 6

diag(A) |> 
  enframe(name = "area", value = "n") |> 
  mutate(area = str_replace(area, "/", " / ")) |> 
  mutate(area = fct_reorder(str_wrap(area, 30), n)) |> 
  summarize(n = sum(n), .by = area) |> 
  mutate(cut = cut(
    x = n, 
    breaks = quantile(n, probs = c(0, 1/3, 2/3, 1)), 
    include.lowest = TRUE, c("Smallest", "Medium", "Largest")
   ) 
  ) |> 
  mutate(cut = fct_reorder(cut, -n)) |> 
  mutate(color = ifelse(n > 130, "steelblue1", "grey")) |> 
  ggplot(aes(n, area, fill = color)) + 
  geom_col(width = 1/2, show.legend = FALSE) +
  geom_text(aes(label = n), nudge_x = 18, size = 3, family = "Optima") +
  labs(y = NULL, x = "count") + 
  theme(axis.text.x = element_blank()) + 
  facet_wrap(~cut, scales = "free_y") + 
  scale_fill_identity() +
  coord_cartesian(xlim = c(0, 250))
```

@fig-areas, however, doesn't give us any picture of the "structure" of the sociological areas of interest---i.e., the pattern of connections which some may describe as coherency. This is what the next section is all about.

## Two-Mode Networks

The direct ties between individuals and areas can be transmogrified---via simple matrix multiplication ---into indirect ties among areas [@agneessens2013; @breiger1974]. The resulting matrix is sometimes called a *two-mode projection.*[^1]

[^1]: *The original network represented by* $\mathbf X$ goes by many names---e.g, affiliation networks, bipartite graphs, two-mode network, etc.

$$
\mathbf{A} = \mathbf{X}^\top \mathbf{X}
$$ {#eq-proj}

Here, we start with a $1112 \times 61$ incidence matrix $\mathbf X$ (with rows representing individuals and columns representing areas of interest. We transform $\mathbf X$ into a new $61 \times 61$ adjacency matrix $\mathbf A$ with each cell $a_{ij}$ corresponding to the number of "shared" or "intersecting" individuals between areas $i$ and $j$.

The diagonal of $\mathbf A$ contains the total number of individuals that chose each area, which corresponds to the same numbers in @fig-areas.

The resulting network, unfortunately, is *very dense.* It only takes one single individual with idiosyncratic tastes to create ties among four otherwise disconnected areas. As a result, the "structure" is one in which everything is connected to everything else, as in @fig-full.[^2]

[^2]: @knoke2021 \[pp. 36\] note three problems with using this sort of projection. First, it entails a loss of "identity information" on one of the two node sets---e.g., the cell entries in $\mathbf A$ don't reveal the specific individuals shared across areas. Second, it results in *very dense* networks, which leads to biases in network measurements---e.g., an artificially high number of triangles [see @opsahl2013]. Third, it obscures the generative process behind tie formation.

```{r}
#| label: fig-full
#| fig-cap: "Full Network (Dense). The colored nodes indicate groups found via the Louvaine community detection algorithm. I wouldn't read too much into this graph."
#| fig-height: 10
#| column: page
#| message: false
#| warning: false

net <- igraph::graph_from_adjacency_matrix(
  adjmatrix = A, 
  mode = "undirected", 
  weighted = TRUE, 
  diag = FALSE
)

V(net)$size <- diag(A)
V(net)$eigen <- igraph::eigen_centrality(net)$vector

vnd <- toVisNetworkData(net, idToLabel = TRUE) 

cluster_num <- membership(cluster_louvain(net))
cluster_col <- RColorBrewer::brewer.pal(n = max(cluster_num), name = "Spectral")

vnd$nodes$value <- vnd$nodes$eigen
vnd$nodes$title <- paste(vnd$nodes$label, "</br>", "Size:", vnd$nodes$size)
vnd$nodes$group <- paste("Group:", LETTERS[cluster_num])
vnd$nodes$color <- cluster_col[cluster_num]
vnd$edges$width <- rescale(vnd$edges$weight)
vnd$edges$title <- paste("Shared Individuals:", vnd$edges$weight)

visNetwork(vnd$nodes, vnd$edges) |> 
  visIgraphLayout(layout = "layout_with_fr", physics = FALSE) |> 
  visEdges(label = list(inherit = "to"), color = "lightblue") |> 
  visNodes(label = list(inherit = "to")) |> 
  visOptions(
    nodesIdSelection = TRUE, selectedBy = "group",
    highlightNearest = list(enabled = TRUE, hover = TRUE, labelOnly = TRUE, degree = 1)
  )
```

**Add a couple of surprising lack of connections e.g., marxists, etc. CLiking around!!**

Because projections, like the one in @eq-proj, result in very dense networks, researchers have found ways to "trim" uninformative ties or extracting "network backbones." These approaches turn HYPOTHESIS TEST

figs a and b show the result of using one such technique disparity filter...

[@domagalski2021],

Some explainer.

If the links between individuals and areas of interest was random, the following procedure would result in only isolate nodes.

Footnote about how the choice of algorithm and threshold is rarely discussed in most publications.

For example, researchers working with text-networks usually "trim" uninformative edges (or "sparsify" the similarity matrix). Fuhse et al. ([2020](https://acastroaraujo-notebooks.netlify.app/posts/2022-02-03-network-backbones/#ref-fuhse2020)), Hoffman et al. ([2018](https://acastroaraujo-notebooks.netlify.app/posts/2022-02-03-network-backbones/#ref-hoffman2018)), Bail ([2016](https://acastroaraujo-notebooks.netlify.app/posts/2022-02-03-network-backbones/#ref-bail2016)). This step is usually skimmed over in most publications.

```{r}
#ok <- which(diag(A) > 15) ## yeah, not necessary
#A <- A[ok, ok]
#A

process <- function(A, alpha) {
  
  stopifnot(class(A) %in% c("matrix", "array", "dgCMatrix"), isSymmetric(A))
  
  net <- backbone::disparity(A, alpha = alpha, class = "igraph", narrative = TRUE)
  
  V(net)$size <- diag(A)
  V(net)$eigen <- igraph::eigen_centrality(net)$vector
  ## delete isolates
  net <- delete_vertices(net, which(degree(net) == 0))
  
  ## visNetwork
  vnd <- toVisNetworkData(net, idToLabel = TRUE) 
  vnd$nodes$value <- vnd$nodes$eigen
  vnd$nodes$title <- paste(vnd$nodes$label, "</br>", "Size:", vnd$nodes$size)
  vnd$edges$width <- rescale(vnd$edges$weight)
  
  vnd$edges$title <- paste("Shared Individuals:", A[cbind(vnd$edges$from, vnd$edges$to)])
  
  return(vnd)
  
}

vnd <- process(A, 0.05)

visNetwork(vnd$nodes, vnd$edges) |> 
  visIgraphLayout(layout = "layout_with_fr", physics = FALSE) |> 
  visEdges(label = list(inherit = "to"), color = "lightblue") |> 
  visNodes(label = list(inherit = "to")) |> 
  visOptions(
    nodesIdSelection = TRUE, 
    highlightNearest = list(enabled = TRUE, hover = TRUE, labelOnly = TRUE, degree = 1)
  ) 


  visNetwork(vnd$nodes, vnd$edges) |> 
   visIgraphLayout(layout = "layout_with_fr", physics = TRUE) |> 
   visEdges(color = list(inherit = "to")) |> 
   visNodes(label = list(inherit = "to")) |> 
   visOptions(
     nodesIdSelection = TRUE,
     highlightNearest = list(enabled = TRUE, hover = TRUE, labelOnly = TRUE, degree = 1)
   ) |> 
   visPhysics(
     solver = "barnesHut", 
     maxVelocity = 3, 
     barnesHut = list(theta = 0.1, gravitationalConstant = -3000, centralGravity = 0.2)
   )   

```

To do: clean up labels

```{r}
i <- seq(0.01, 0.1, by = 0.02)

nets <- map(i, function(x) {
  
  out <- backbone::disparity(A, alpha = x, class = "igraph", signed = FALSE)
  V(out)$size <- diag(A)
  V(out)$degree <- degree(out)
  
  cluster <- as.integer(membership(cluster_walktrap(out))) 
  tbl <- sort(table(cluster)[table(cluster) > 1], decreasing = TRUE) 
  lookup <- setNames(letters[seq_along(tbl)], as.integer(names(tbl)))
  
  V(out)$group <- lookup[as.character(cluster)]
  V(out)$group[is.na(V(out)$group)] <- "isolate"
  V(out)$name <- stringr::str_wrap(V(out)$name, 12)
  
  return(out)
  
})
```

::: {.panel-tabset .column-page-inset style="height: 1000px;"}
```{r}
#| output: asis

res <- purrr::imap_chr(nets, \(x, id) {
    knitr::knit_child(text = c(
      "## λ: `r i[[id]]`",
      "", 
      "```{r}",
      "#| echo: false",
      "#| fig-height: 10",
      "vis_plot(x)",
      "```",
      "",
      ""
    ), envir = environment(), quiet = TRUE)
  })

cat(res, sep = '\n')
```
:::

</br></br>

## Extra

We used the backbone package for R (v2.1.2; Neal, 2022) to extract the unweighted backbone of a weighted and undirected unipartite network containing 61 nodes. An edge was retained in the backbone if its weight was statistically significant (alpha = 0.05) using the disparity filter (Serrano et al., 2009). This reduced the number of edges by 96.3%, and reduced the number of connected nodes by 34.4%.

Neal, Z. P. 2022. backbone: An R Package to Extract Network Backbones. PLOS ONE, 17, e0269137. [https://doi.org/10.1371/journal.pone.0269137](https://doi.org/10.1371/journal.pone.0269137Serrano,)

Serrano, M. A., Boguna, M., & Vespignani, A. (2009). Extracting the multiscale backbone of complex weighted networks. Proceedings of the National Academy of Sciences, 106(16), 6483-6488. <https://doi.org/10.1073/pnas.0808904106>

## Sample

```{r}
#| echo: false
#| label: tbl-sample
#| tbl-cap: "Number of individuals extracted from the ASA member directory"
#| tbl-cap-location: margin

d |> 
  count(institution, sort = TRUE) |> 
  mutate(prop = n / sum(n)) |> 
  gt::gt(rowname_col = "institution") |> 
  gt::tab_header("Sample") |>
  gt::fmt_percent(columns = prop) |> 
  gt::cols_align(columns = everything(), align = "center") |> 
  gt::grand_summary_rows(
    columns = prop,
    fns = list(label = "Total", fn = "sum"), 
    side = "bottom", align = "right", fmt = ~ fmt_percent(., decimals = 0)
  ) |> 
  gt::grand_summary_rows(
    columns = n,
    fns = list(label = "Total", fn = "sum"), 
    side = "bottom", align = "right", fmt = ~ fmt_integer(.)
  ) |> 
  gt::cols_label(prop = "%") |> 
  gt::tab_style(style = cell_text(weight = "bold"), locations = cells_column_labels()) |> 
  gt::opt_table_font(font = "Optima") 

```

```{r}
#| eval: false

full <- igraph::graph_from_adjacency_matrix(M, "undirected", weighted = TRUE, diag = FALSE)


V(full)$eigen <- igraph::eigen_centrality(full)$vector

library(ggraph)
library(tidygraph)

vnd <- toVisNetworkData(full, idToLabel = TRUE) 

vnd$nodes$value <- vnd$nodes$eigen
vnd$edges$width <- log(vnd$edges$weight)
vnd$edges$title <- paste("Co-occurrence:", vnd$edges$weight)

visNetwork(vnd$nodes, vnd$edges) |> 
  visIgraphLayout(layout = "layout_with_kk", physics = FALSE)
   visEdges(color = list(inherit = "to")) |> 
   visNodes(label = list(inherit = "to")) 
  # visOptions(
  #   selectedBy = "group",
  #     nodesIdSelection = TRUE,
  #   highlightNearest = list(enabled = TRUE, hover = TRUE, labelOnly = TRUE, degree = 1)
  # ) |> 
  visPhysics(
    solver = "barnesHut", 
    maxVelocity = 3, 
    barnesHut = list(theta = 0.1, gravitationalConstant = -3000, centralGravity = 0.5)
  )   


full |> 
  as_tbl_graph() |> 
  mutate(degree = centrality_degree()) |> 
  ggraph() + 
  geom_edge_fan(alpha = 1/2) +
  geom_node_label(aes(label = str_wrap(name, 12), alpha = degree), size = 3, show.legend = FALSE)


n <- sum(M)
cols <- colSums(M) 
rows <- rowSums(M) 
expected <- outer(rows, cols) 
expected

expected[1, 5]
M[1, 5]

```

```{r}
#| eval: false

sub <- subgraph(full, igraph::cluster_leiden(full)[[1]])



tidygraph::as_tbl_graph(sub)

#A <- igraph::as_adjacency_matrix(sub, attr = "weight", sparse = FALSE)

library(visNetwork)

net <- backbone::disparity(A, class = "igraph")
vnd <- toVisNetworkData(net)

vnd$nodes <- left_join(vnd$nodes, enframe(diag(M), name = "id", value = "size"))

  
vnd$nodes$label <- str_wrap(vnd$nodes$id, 10)
vnd$nodes$value <- vnd$nodes$size

visNetwork(vnd$nodes, vnd$edges) |> 
  visIgraphLayout(layout = "layout_with_fr", physics = TRUE) |> 
  visEdges(color = list(inherit = "to")) |> 
  visNodes(label = list(inherit = "to")) 


ggraph("kk") + 
  geom_edge_fan() +
  geom_node_point() + 
  geom_node_label(aes(label = str_wrap(name, 4)), size = 3)

out <- princomp(A)
out$loadings 

s <- svd(A)

library("quanteda")
library("quanteda.textmodels")


D <- as.dfm(t(A)) 
  #quanteda::dfm_tfidf(
  #  scheme_tf = "prop",
  #  scheme_df = "inverse"
  #)

lsa <- textmodel_lsa(D, nd = 10)

colSums(A) |> sort(decreasing = TRUE)


out <- princomp(M)

str(out)

out$rotation[, 1:2] |> 
  as_tibble(rownames = "id") |> 
  ggplot(aes(PC1, PC2)) + 
  geom_label(aes(label = str_wrap(id, 4)), size = 2)


out$rotation[, 1:2] |> 
  as_tibble(rownames = "id") |> 
  pivot_longer(!id, names_to = "component") |> 
  group_by(component) |> 
  filter(abs(value) > 0.02) |> 
  ggplot(aes(value, str_wrap(id, 5))) + 
  geom_col() + 
  facet_wrap(~component, scales = "free") 

as_tibble(lsa$docs, rownames = "id") |> 
  ggplot(aes(V1, V2)) + 
  geom_label(aes(label = str_wrap(id, 4)), size = 2)
```

```{r}

```
